# Шифр Цезаря

**Шифр Цезаря** (шифр сдвига) — один из самых простых и наиболее широко известных методов шифрования. Шифр Цезаря — это вид [шифра подстановки](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8), в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите.

Шифр подстановки — метод шифрования с заменой элементов исходного открытого текста другими, в соответствии с неким правилом.

Например, в шифре со сдвигом вправо на 33 позиции символ `A` заменяется символом `D`, символ `B` — символом `E`, и так далее, до символа `Z`, заменяемого символом `C`.

[![Шифр Цезаря со сдвигом на 3](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Caesar3.svg/320px-Caesar3.svg.png)](https://commons.wikimedia.org/wiki/File:Caesar3.svg?uselang=ru)

Шифр Цезаря со сдвигом на 3

![](https://ucarecdn.com/5f116490-13e7-42ac-bec1-1b0e0a20161f/)Шифр назван в честь римского полководца [Гая Юлия Цезаря](https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%B9_%D0%AE%D0%BB%D0%B8%D0%B9_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8C), использовавшего его для секретной переписки со своими генералами.

Шифр Цезаря легко взламывается и не имеет почти никакого практического применения.

## Пример

Шифрование с использованием ключа k=3k=3. Буква «Е» «сдвигается» на три буквы вперед и становится буквой «З». Твердый знак, перемещенный на три буквы вперед, становится буквой «Э», буква «Я», перемещенная на три буквы вперед, становится буквой «В», и так далее:

```no-highlight
Исходный алфавит: А Б В Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я
Шифрованный:      Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я А Б В 
```

**Оригинальный текст:**

```no-highlight
Съешь же ещё этих мягких французских булок, да выпей чаю.
```

**Шифрованный текст:**

```no-highlight
Фэзыя йз зьи ахлш пвёнлш чугрщцкфнлш дцосн, жг еютзм ъгб.
```

## Взлом шифра

Шифр Цезаря может быть легко взломан даже в случае, когда взломщик знает только зашифрованный текст. Можно рассмотреть две ситуации:

1.  Взломщик знает (или предполагает), что использовался простой шифр подстановки, но не знает, что это — схема Цезаря.
2.  Взломщик знает, что использовался шифр Цезаря, но не знает значение сдвига.

В первом случае шифр может быть взломан с применением метода [частотного анализа](https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BE%D1%82%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7 "Частотный анализ"). Используя этот метод, взломщик, вероятно, быстро заметит регулярность в решении и поймет, что используемый шифр — шифр Цезаря.

![](https://upload.wikimedia.org/wikipedia/commons/e/e7/English-slf-ru.png)

Распределение букв в типичном образце текста на английском  
языке имеет характерный и предсказуемый вид

Во втором случае взлом шифра еще более прост. Существует не так много вариантов значений сдвига (2626 для английского языка, 3232 для русского языка), все они могут быть проверены перебором.

## Примечания

**Примечание 1.** Используемое преобразование в шифре Цезаря обычно обозначают как `ROT N`, где `N` — сдвиг, `ROT` — сокращение от слова ROTATE, в данном случае «циклический сдвиг». Например, обозначение `ROT 2` обозначает сдвиг на 22 позиции, то есть, «а» превращается в «в», «б» в «г», и так далее, и в конце «ю» превращается в «а» а «я» — в «б».

**Примечание 2.** Число разных преобразований зависит от длины алфавита:

-   для русского языка возможно 3232 разных преобразования (преобразования `ROT 0` и `ROT 33` сохраняют исходный текст, а дальше начинаются уже повторения);
-   для английского языка возможны 2525 разных преобразований (преобразования `ROT 0` и `ROT 26` сохраняют исходный текст, а дальше начинаются уже повторения).

**Примечание 3.** Неалфавитные символы — знаки препинания, пробелы, цифры — не меняются.

**Примечание 4.** Естественным развитием шифра Цезаря стал [шифр Виженера](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%92%D0%B8%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B0).

```python
def caesar(text, offset):
    en_alphabet = [chr(i) for i in range(65,91)] + [chr(j) for j in range(97,123)]
    ru_alphabet = [chr(i) for i in range(1040,1104)]

    first_syb = [i for i in text if i.isalpha()][0]

    result = ""
    if first_syb in en_alphabet:
        alphabet = en_alphabet; mod = 26
    else:
        alphabet = ru_alphabet; mod = 32

    size = len(text)
    for i in range(size):
        syb = text[i]
        if syb.isalpha():
            if syb.isupper():
                result += alphabet[(alphabet.index(syb) + offset) % mod]
            else:
                result += alphabet[(alphabet.index(syb) + offset) % mod + mod]
        else:
            result += syb
    return result

str = input().split()
print(*[caesar(word, len([i for i in word if i.isalpha()])) for word in str])
```

